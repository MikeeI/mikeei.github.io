<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="An in-depth comparison of Firecracker and QEMU, and why we chose to switch from Firecracker to QEMU for Hocus."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Why We Replaced Firecracker with QEMU"><meta property="og:description" content="An in-depth comparison of Firecracker and QEMU, and why we chose to switch from Firecracker to QEMU for Hocus."><meta property="og:type" content="article"><meta property="og:url" content="https://mikeei.github.io/posts/blog_post_2023_07_10/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-10T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-10T00:00:00+00:00"><title>Why We Replaced Firecracker with QEMU | Mikeei Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/favicon.png alt=Logo><span>Mikeei Blog</span></a></h2><ul><li><a href=/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Why We Replaced Firecracker with QEMU</strong>
<label for=toc-control></label></div></header><article class=markdown><h1><a href=/posts/blog_post_2023_07_10/>Why We Replaced Firecracker with QEMU</a></h1><h5>July 10, 2023</h5><p><img src=https://hocus.dev/blog/img/hocus-logo-with-text.png alt="Hocus Logo"></p><h1 id=why-we-replaced-firecracker-with-qemu>Why We Replaced Firecracker with QEMU
<a class=anchor href=#why-we-replaced-firecracker-with-qemu>#</a></h1><p><em>July 10, 2023</em><br><em>Hugo Dutka</em><br><em>Co-founder at Hocus</em></p><p>Firecracker, the microVM hypervisor, is renowned for being lightweight, fast, and secure. It&rsquo;s excellent for running short-lived workloads, which is why it&rsquo;s the backbone of AWS Lambda. Our initial prototype for Hocus, a self-hosted alternative to Gitpod and GitHub Codespaces, utilized Firecracker. However, after weeks of testing, we decided to entirely replace it with QEMU. A little-known fact about Firecracker is its lack of support for many modern hypervisor features, such as dynamic RAM management, which is vital for long-lived workloads. In this post, I will explain why Firecracker might not be the best hypervisor choice and when you should avoid it.</p><h2 id=firecracker-optimizes-for-short-lived-workloads>Firecracker Optimizes for Short-Lived Workloads
<a class=anchor href=#firecracker-optimizes-for-short-lived-workloads>#</a></h2><p>The creators of Firecracker state that:</p><blockquote><p>&ldquo;Firecracker has a minimalist design. It excludes unnecessary devices and guest-facing functionality to reduce the memory footprint and attack surface area of each microVM.&rdquo;</p></blockquote><p>The term &ldquo;unnecessary&rdquo; is intriguing - if this functionality is unnecessary, why was it incorporated into other hypervisors? The definition of &ldquo;unnecessary&rdquo; must be understood in the context of what Firecracker was built for. These excluded features are unnecessary for AWS Lambda, which spins up VMs to run short function calls and then shuts them down. If you&rsquo;re running a different kind of workload, like a VM that contains your development environment or a self-hosted GitHub Actions agent, these features cease to be unnecessary. Your VM will run for hours, days, or even months without stopping, unlike the typical Firecracker VM, which runs for seconds or minutes.</p><h2 id=firecracker-not-so-lightweight-after-all>Firecracker, Not So Lightweight After All
<a class=anchor href=#firecracker-not-so-lightweight-after-all>#</a></h2><p>Here are the two most significant features Firecracker lacks:</p><ol><li>Dynamic memory management - Firecracker&rsquo;s RAM footprint starts low, but once a workload inside allocates RAM, Firecracker will never return it to the host system. After running several workloads inside, you end up with an idling VM that consumes 32 GB of RAM on the host, even though it doesn&rsquo;t need any of it.</li><li>Discard operations on storage - if you create a 10 GB file inside a VM and then delete it, the backing space won&rsquo;t be reclaimed on the host. The VM will occupy that disk space until you delete the entire VM drive.</li></ol><p>These deficiencies make Firecracker a memory and disk space hog. The plot below shows the memory usage of the same memory-intensive workload running in QEMU and Firecracker virtual machines.</p><p><img src=https://hocus.dev/blog/assets/images/vm-mem-usage-ae3ffeb0cc6a2df2f662597c653d9bf4.png alt="QEMU vs Firecracker VM Memory Usage"></p><p>The workload in Firecracker finishes running around the 200-second mark, and in QEMU around the 250-second mark. It&rsquo;s not a performance difference; it&rsquo;s just when I manually stopped them.</p><h2 id=other-features-firecracker-is-missing>Other Features Firecracker Is Missing
<a class=anchor href=#other-features-firecracker-is-missing>#</a></h2><ul><li>GPU support - if you need a GPU inside the VM, you have to pick a different hypervisor.</li><li>High-performance disk IO - when you connect multiple drives to the VM and run intensive IO operations, you will likely run into a bottleneck. Firecracker uses a virtio-blk implementation that isnâ€™t as memory-hungry as alternatives, but has a smaller throughput.</li></ul><h2 id=qemu-is-not-perfect-though>QEMU is Not Perfect Though
<a class=anchor href=#qemu-is-not-perfect-though>#</a></h2><p>The main issue we&rsquo;ve had with QEMU is that it has too many options you need to configure. For instance, enabling your VM to return unused RAM to the host requires at least three challenging tasks:</p><ol><li>Knowing that the feature even exists (it&rsquo;s called free page reporting and you have to specifically enable it in QEMU)</li><li>Understanding that an obscure feature of Linux called DAMON exists, knowing what it&rsquo;s for, knowing how to configure it, and compiling a guest Linux kernel that supports it</li><li>Knowing that you need to disable transparent huge pages on the guest, otherwise the VM will never return large amounts of memory</li></ol><p>It took us two months of experimentation, reading through the source code of Firecracker, QEMU, and other hypervisors to develop a reliable QEMU proof of concept. To comprehend DAMON configuration, my co-founder spent days running benchmarks and conversing with one of its authors. It&rsquo;s great that we could talk and we are grateful that the author spent the time to help us, but it shows that the technology is not easily accessible yet.</p><h2 id=conclusion>Conclusion
<a class=anchor href=#conclusion>#</a></h2><p>QEMU has the features you need to run general-purpose workloads, but configuring it requires a lot of time and patience. If you want to run short-lived, untrusted workloads, Firecracker is a great choice. However, if you just want to run your development environment in a VM, you can use Hocus. We&rsquo;ve done all the hard work for you already. It&rsquo;s still in alpha, but you can already check it out on <a href=https://github.com/hocus-dev>GitHub</a>.</p><p><em>Tags: qemu, firecracker</em></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div></main></body></html>